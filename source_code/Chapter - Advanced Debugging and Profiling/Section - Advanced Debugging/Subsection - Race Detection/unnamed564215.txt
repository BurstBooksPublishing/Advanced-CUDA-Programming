__global__ void raceConditionKernel(int *data, int *result, int N) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < N) {
        // Potential race condition: multiple threads may write to result[0]
        result[0] += data[idx];
    }
}

void detectRaceCondition() {
    int N = 1024;
    int *h_data = (int *)malloc(N * sizeof(int));
    int *h_result = (int *)malloc(sizeof(int));
    int *d_data, *d_result;

    // Initialize host data
    for (int i = 0; i < N; i++) {
        h_data[i] = 1;
    }
    h_result[0] = 0;

    // Allocate device memory
    cudaMalloc(&d_data, N * sizeof(int));
    cudaMalloc(&d_result, sizeof(int));

    // Copy data to device
    cudaMemcpy(d_data, h_data, N * sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(d_result, h_result, sizeof(int), cudaMemcpyHostToDevice);

    // Launch kernel with potential race condition
    raceConditionKernel<<<(N + 255) / 256, 256>>>(d_data, d_result, N);

    // Copy result back to host
    cudaMemcpy(h_result, d_result, sizeof(int), cudaMemcpyDeviceToHost);

    // Print result (may be incorrect due to race condition)
    printf("Result: %d\n", h_result[0]);

    // Free memory
    free(h_data);
    free(h_result);
    cudaFree(d_data);
    cudaFree(d_result);
}